= VIATRA CPS Demonstrator
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
ifndef::rootdir[:rootdir: ../]
ifndef::imagesdir[{rootdir}/../images]
:toclevels: 2
:toc:
:toc2:
:icons: font
:chapterdir: .
:experimental:


:chapterdir: .
== Overview

The CPS Demonstrator is specified to cover a usual workflow in Model-driven Engineering, where a system is (1) first described in a **source domain model**, then (2) automated **model-to-model transformations** are used to derive a **target domain model**. Finally, (3) **model-to-text transformation** is performed to generate code from the target domain. In addition, a **model generator** that can automatically create source domain models can support the correctness **testing** and **performance evaluation** of the components.

[fig:cps-overview]
.CPS Demonstrator overview
image::cps/overview.png[CPS Demonstrator overview]

=== Domains

In this example, the source domain (CPS) represents a **Cyber-Physical System** with applications with dynamic behaviour allocated to connected hosts. The target domain (Deployment) represents the system **deployment** configuration, with stateful applications contained by hosts. Instance models of the two domains are connected by a traceability model for maintaining **correspondence** between related elements. These domains are modelled in **Ecore** and instance models are handled using the code generated by EMF.

For more information about the domains, consult <<Domains#>>

=== CPS-to-Deployment Transformation

The <<CPS-to-Deployment-Transformation#,CPS-to-Deployment>> model-to-model transformation derives a deployment model from a CPS model and also creates the correspondence in a traceability model. In addition, model-to-model transformations should be able **synchronize changes** in the CPS model to the deployment model and the traceability model. <<Alternative-transformation-methods#,Alternative transformation methods>> can be implemented, with some variant offering only **batch execution** functionalities (recreating the deployment and traceability models every time), while other alternatives are capable of **incremental execution**, where only changes are propagated.

The transformation creates deployment hosts for each CPS host instance, then creates deployment applications in these hosts for all application instances allocated to the corresponding CPS host. Next, the state machine of the application type for each mapped application instance is mapped to a deployment behaviour of the deployment application. This includes creating states and transitions as well, although the two metamodels represent state machines and behaviours in a slightly different way. Finally, transition actions are processed and trigger references are created between behaviour transitions if the model structure and the actions are set up in a given way (<<CPS-to-Deployment-Transformation#rules,Step 6. in the specification>>).


=== Deployment Code Generation

The <<Code-Generator-Distributed-realization-Xtend-templates#, Deployment Code Generation>> model-to-text transformation takes a deployment model and outputs **Java code** that can simulate the dynamic behaviour of the system. Each host is executed on separate threads by **host runners**, while inter-host triggers are implemented by message passing through a simple **communication network** object. Once again, based on a single specification, multiple model-to-text alternatives can be provided, with incremental approaches re-generating only parts of the source code that are affected by deployment model changes. These changes are collected using a <<Deployment-change-monitor#,deployment change monitor>>, which uses VIATRA Query to **aggregate** low level deployment model **modifications** and **provide deltas** that specify the changed elements (hosts, applications, behaviours).

The code generator creates source code fragments from elements of the deployment model, these include:

* **Deployment** for creating the top level configuration that sets up host objects
* **Host** for creating the code that sets the applications for a host
* **Application** for creating code that sets up an application, with a current state
* **Behavior** for creating code for a deployment behaviour including states and transitions (with triggers).

The generated code uses base classes that contain model-independent code and some common classes that are used for the execution (e.g. communication network).

=== Further information

* <<Generate-CPS-models#,Generating example models>>
* <<Incremental-Viewers#, VIATRA Viewers example>>
* <<Live-Validation#, Model Validation example>>
* The transformation components are tested with *unit tests* and *integration tests*
  * <<CPS-to-Deployment-Unit-Tests#,Unit tests for the M2M transformation>>
* A <<Model-Generator#,CPS Model Generator>> is available to create arbitrary sized CPS model instances
* The CPS demonstrator is also used as a performance benchmark for VIATRA, see see the link:https://github.com/viatra/viatra-cps-benchmark/wiki[VIATRA CPS Benchmark] wiki for details.
