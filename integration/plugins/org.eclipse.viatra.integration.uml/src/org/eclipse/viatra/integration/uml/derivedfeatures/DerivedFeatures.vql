package org.eclipse.viatra.integration.uml.derivedfeatures

import "http://www.eclipse.org/uml2/5.0.0/UML"

// * Union

@Surrogate(feature = "input")
pattern actionInput(source: Action, target: InputPin)
{ AddStructuralFeatureValueAction.insertAt(source, target); } or 
{ AddVariableValueAction.insertAt(source, target); } or 
{ CallOperationAction.target(source, target); } or 
{ ClearAssociationAction.object(source, target); } or 
{ DestroyObjectAction.target(source, target); } or 
{ InvocationAction.argument(source, target); } or 
{ LinkAction.inputValue(source, target); } or 
{ OpaqueAction.inputValue(source, target); } or 
{ RaiseExceptionAction.exception(source, target); } or
{ ReadIsClassifiedObjectAction.object(source, target); } or 
{ ReadLinkObjectEndAction.object(source, target); } or 
{ ReadLinkObjectEndQualifierAction.object(source, target); } or 
{ ReclassifyObjectAction.object(source, target); } or 
{ ReduceAction.collection(source, target); } or 
{ RemoveStructuralFeatureValueAction.removeAt(source, target); } or 
{ RemoveVariableValueAction.removeAt(source, target); } or 
{ ReplyAction.replyValue(source, target); } or 
{ ReplyAction.returnInformation(source, target); } or 
{ SendObjectAction.target(source, target); } or 
{ SendSignalAction.target(source, target); } or 
{ StartClassifierBehaviorAction.object(source, target); } or 
{ StartObjectBehaviorAction.object(source, target); } or 
{ StructuralFeatureAction.object(source, target); } or 
{ StructuredActivityNode.structuredNodeInput(source, target); } or 
{ TestIdentityAction.first(source, target); } or 
{ TestIdentityAction.second(source, target); } or 
{ UnmarshallAction.object(source, target); } or 
{ WriteStructuralFeatureAction.value(source, target); } or 
{ WriteVariableAction.value(source, target); }

@Surrogate(feature = "output")
pattern actionOutput(source: Action, target: OutputPin)
{ AcceptCallAction.returnInformation(source, target); } or 
{ AcceptEventAction.result(source, target); } or 
{ CallAction.result(source, target); } or 
{ ClearStructuralFeatureAction.result(source, target); } or 
{ CreateLinkObjectAction.result(source, target); } or 
{ CreateObjectAction.result(source, target); } or 
{ OpaqueAction.outputValue(source, target); } or 
{ ReadExtentAction.result(source, target); } or 
{ ReadIsClassifiedObjectAction.result(source, target); } or 
{ ReadLinkAction.result(source, target); } or 
{ ReadLinkObjectEndAction.result(source, target); } or 
{ ReadLinkObjectEndQualifierAction.result(source, target); } or 
{ ReadSelfAction.result(source, target); } or 
{ ReadStructuralFeatureAction.result(source, target); } or 
{ ReadVariableAction.result(source, target); } or 
{ ReduceAction.result(source, target); } or 
{ StructuredActivityNode.structuredNodeOutput(source, target); } or 
{ TestIdentityAction.result(source, target); } or 
{ UnmarshallAction.result(source, target); } or 
{ ValueSpecificationAction.result(source, target); } or 
{ WriteStructuralFeatureAction.result(source, target); }

@Surrogate(feature = "group")
pattern activityGroup(source: Activity, target: ActivityGroup)
{ Activity.ownedGroup(source, target); } or 
{ Activity.partition(source, target); } or 
{ Activity.structuredNode(source, target); }

@Surrogate(feature = "inActivity")
pattern activityGroupInActivity(source: ActivityGroup, target: Activity){
    // opposite of Activity.group
    find activityGroup(target, source);
}

@Surrogate(feature = "node")
pattern activityNode(source: Activity, target: ActivityNode)
{ Activity.ownedNode(source, target); } or 
{ Activity.structuredNode(source, target); }

@Surrogate(feature = "activity")
pattern activityNodeActivity(source: ActivityNode, target: Activity){
    // opposite of Activity.node
    find activityNode(target, source);
}

@Surrogate(feature = "inGroup")
pattern activityEdgeInGroup(source: ActivityEdge, target: ActivityGroup)
{ ActivityEdge.inPartition(source, target); } or 
{ ActivityEdge.inStructuredNode(source, target); }

@Surrogate(feature = "containedEdge")
pattern activityGroupContainedEdge(source: ActivityGroup, target: ActivityEdge)
{
    // opposite of ActivityGroup.containedEdge
    find activityEdgeInGroup(target, source);
}

@Surrogate(feature = "containedNode")
pattern activityGroupContainedNode(source: ActivityGroup, target: ActivityNode)
{ ActivityPartition.node(source, target); } or 
{ InterruptibleActivityRegion.node(source, target); } or 
{ StructuredActivityNode.node(source, target); }

@Surrogate(feature = "inGroup")
pattern activityNodeInGroup(source: ActivityNode, target: ActivityGroup)
{
    // opposite of ActivityGroup.containedNode
    find activityGroupContainedNode(target, source);
}

@Surrogate(feature = "subgroup")
pattern activityGroupSubgroup(source: ActivityGroup, target: ActivityGroup)
{ ActivityPartition.subpartition(source, target); }

@Surrogate(feature = "superGroup")
pattern activityGroupSuperGroup(source: ActivityGroup, target: ActivityGroup)
{ 
    // opposite of ActivityGroup.subGroup
    find activityGroupSubgroup(target, source);
}

@Surrogate(feature = "attribute")
pattern classifierAttribute(source: Classifier, target: Property)
{ Artifact.ownedAttribute(source, target); } or 
{ DataType.ownedAttribute(source, target); } or 
{ Interface.ownedAttribute(source, target); } or 
{ Signal.ownedAttribute(source, target); } or 
{ StructuredClassifier.ownedAttribute(source, target); }

@Surrogate(feature = "feature")
pattern classifierFeature(source: Classifier, target: Feature)
{ Artifact.ownedOperation(source, target); } or 
{ Association.ownedEnd(source, target); } or 
{ Class.ownedOperation(source, target); } or 
{ Class.ownedReception(source, target); } or 
{ find classifierAttribute(source, target); } or 
{ DataType.ownedOperation(source, target); } or 
{ Interface.ownedOperation(source, target); } or 
{ Interface.ownedReception(source, target); } or 
{ StructuredClassifier.ownedConnector(source, target); }

@Surrogate(feature = "featuringClassifier")
pattern featureFeaturingClassifier(source: Feature, target: Classifier)
{
    // opposite of Classifier.feature
    find classifierFeature(target, source);
}

@Surrogate(feature = "source")
pattern directedRelationshipSource(source: DirectedRelationship, target: Element)
{ Dependency.client(source, target); } or 
{ ElementImport.importingNamespace(source, target); } or 
{ Extend.^extension(source, target); } or 
{ Generalization.specific(source, target); } or 
{ Include.includingCase(source, target); } or 
{ InformationFlow.informationSource(source, target); } or 
{ PackageImport.importingNamespace(source, target); } or 
{ PackageMerge.receivingPackage(source, target); } or 
{ ProfileApplication.applyingPackage(source, target); } or 
{ ProtocolConformance.specificMachine(source, target); } or 
{ TemplateBinding.boundElement(source, target); }

@Surrogate(feature = "target")
pattern directedRelationshipTarget(source: DirectedRelationship, target: Element)
{ Dependency.supplier(source, target); } or 
{ ElementImport.importedElement(source, target); } or 
{ Extend.extendedCase(source, target); } or 
{ Generalization.general(source, target); } or 
{ Include.addition(source, target); } or 
{ InformationFlow.informationTarget(source, target); } or 
{ PackageImport.importedPackage(source, target); } or 
{ PackageMerge.mergedPackage(source, target); } or 
{ ProfileApplication.appliedProfile(source, target); } or 
{ ProtocolConformance.generalMachine(source, target); } or 
{ TemplateBinding.signature(source, target); }

@Surrogate(feature = "ownedElement")
pattern elementOwnedElement(source: Element, target: Element)
{ Abstraction.mapping(source, target); } or 
{ AcceptEventAction.trigger(source, target); } or 
{ find actionInput(source, target); } or 
{ Action.localPostcondition(source, target); } or 
{ Action.localPrecondition(source, target); } or 
{ find actionOutput(source, target); } or 
{ ActionInputPin.fromAction(source, target); } or 
{ Activity.edge(source, target); } or 
{ find activityGroup(source, target); } or 
{ find activityNode(source, target); } or 
{ ActivityEdge.guard(source, target); } or 
{ ActivityEdge.weight(source, target); } or 
{ find activityGroupSubgroup(source, target); } or 
{ Artifact.manifestation(source, target); } or 
{ BehavioredClassifier.interfaceRealization(source, target); } or 
{ ChangeEvent.changeExpression(source, target); } or 
{ Classifier.collaborationUse(source, target); } or 
{ Classifier.generalization(source, target); } or 
{ Classifier.substitution(source, target); } or 
{ CollaborationUse.roleBinding(source, target); } or 
{ CombinedFragment.cfragmentGate(source, target); } or 
{ CombinedFragment.operand(source, target); } or 
{ Component.realization(source, target); } or 
{ ConditionalNode.clause(source, target); } or 
{ Connector.end(source, target); } or 
{ Constraint.specification(source, target); } or 
{ Deployment.configuration(source, target); } or 
{ DeploymentTarget.deployment(source, target); } or 
{ Duration.expr(source, target); } or 
{ Element.ownedComment(source, target); } or 
{ ExecutableNode.handler(source, target); } or 
{ Expression.operand(source, target); } or 
{ Extend.condition(source, target); } or 
{ InstanceSpecification.slot(source, target); } or 
{ InstanceSpecification.specification(source, target); } or 
{ Interaction.action(source, target); } or 
{ InteractionConstraint.maxint(source, target); } or 
{ InteractionConstraint.minint(source, target); } or 
{ InteractionFragment.generalOrdering(source, target); } or 
{ InteractionOperand.guard(source, target); } or 
{ InteractionUse.actualGate(source, target); } or 
{ InteractionUse.argument(source, target); } or 
{ InteractionUse.returnValue(source, target); } or 
{ JoinNode.joinSpec(source, target); } or 
{ Lifeline.selector(source, target); } or 
{ LinkAction.endData(source, target); } or 
{ LinkEndData.qualifier(source, target); } or 
{ LoopNode.loopVariable(source, target); } or 
{ Message.argument(source, target); } or 
{ MultiplicityElement.lowerValue(source, target); } or 
{ MultiplicityElement.upperValue(source, target); } or 
{ NamedElement.nameExpression(source, target); } or 
{ Namespace.elementImport(source, target); } or 
{ find namespaceOwnedMember(source, target); } or 
{ Namespace.packageImport(source, target); } or 
{ ObjectNode.upperBound(source, target); } or 
{ Package.packageMerge(source, target); } or 
{ Package.profileApplication(source, target); } or 
{ Parameter.defaultValue(source, target); } or 
{ ParameterSet.condition(source, target); } or 
{ Property.defaultValue(source, target); } or 
{ Property.qualifier(source, target); } or 
{ ProtocolStateMachine.conformance(source, target); } or 
{ Slot.value(source, target); } or 
{ State.deferrableTrigger(source, target); } or 
{ State.doActivity(source, target); } or 
{ State.entry(source, target); } or 
{ State.exit(source, target); } or 
{ StateInvariant.invariant(source, target); } or 
{ Stereotype.icon(source, target); } or 
{ StringExpression.subExpression(source, target); } or 
{ StructuredActivityNode.edge(source, target); } or 
{ StructuredActivityNode.node(source, target); } or 
{ TemplateBinding.parameterSubstitution(source, target); } or 
{ TemplateParameter.ownedDefault(source, target); } or 
{ TemplateParameter.ownedParameteredElement(source, target); } or 
{ TemplateParameterSubstitution.ownedActual(source, target); } or 
{ TemplateSignature.ownedParameter(source, target); } or 
{ TemplateableElement.ownedTemplateSignature(source, target); } or 
{ TemplateableElement.templateBinding(source, target); } or 
{ TimeEvent.when(source, target); } or 
{ TimeExpression.expr(source, target); } or 
{ Transition.effect(source, target); } or 
{ Transition.trigger(source, target); } or 
{ ValuePin.value(source, target); } or 
{ ValueSpecificationAction.value(source, target); }

@Surrogate(feature = "owner")
pattern elementOwner(source: Element, target: Element){
    // opposite of Element.ownedElement
    find elementOwnedElement(target, source);
}

private pattern propertyClass(property : Property, cls : Class) {
    find elementOwnedElement(cls, property);
}

@Surrogate(feature = "member")
pattern namespaceMember(source: Namespace, target: NamedElement)
{ Association.memberEnd(source, target); } or 
{ find classifierFeature(source, target); } or 
// TODO { find classifierInheritedMember(source, target); } or 
{ find namespaceImportedMember(source, target); } or 
{ find namespaceOwnedMember(source, target); } or 
{ find structuredClassifierRole(source, target); }

@Surrogate(feature = "ownedMember")
pattern namespaceOwnedMember(source: Namespace, target: NamedElement)
{ Activity.variable(source, target); } or 
{ Artifact.nestedArtifact(source, target); } or 
{ Artifact.ownedAttribute(source, target); } or 
{ Artifact.ownedOperation(source, target); } or 
{ Association.ownedEnd(source, target); } or 
{ Behavior.ownedParameter(source, target); } or 
{ Behavior.ownedParameterSet(source, target); } or 
{ BehavioralFeature.ownedParameter(source, target); } or 
{ BehavioralFeature.ownedParameterSet(source, target); } or 
{ BehavioredClassifier.ownedBehavior(source, target); } or 
{ Class.nestedClassifier(source, target); } or 
{ Class.ownedOperation(source, target); } or 
{ Class.ownedReception(source, target); } or 
{ Classifier.ownedUseCase(source, target); } or 
{ Component.packagedElement(source, target); } or 
{ DataType.ownedAttribute(source, target); } or 
{ DataType.ownedOperation(source, target); } or 
{ Enumeration.ownedLiteral(source, target); } or 
{ Interaction.formalGate(source, target); } or 
{ Interaction.fragment(source, target); } or 
{ Interaction.lifeline(source, target); } or 
{ Interaction.message(source, target); } or 
{ InteractionOperand.fragment(source, target); } or 
{ Interface.nestedClassifier(source, target); } or 
{ Interface.ownedAttribute(source, target); } or 
{ Interface.ownedOperation(source, target); } or 
{ Interface.ownedReception(source, target); } or 
{ Interface.protocol(source, target); } or 
{ Namespace.ownedRule(source, target); } or 
{ Node.nestedNode(source, target); } or 
{ Package.packagedElement(source, target); } or 
{ Region.subvertex(source, target); } or 
{ Region.transition(source, target); } or 
{ Signal.ownedAttribute(source, target); } or 
{ State.connection(source, target); } or 
{ State.connectionPoint(source, target); } or 
{ State.region(source, target); } or 
{ StateMachine.connectionPoint(source, target); } or 
{ StateMachine.region(source, target); } or 
{ StructuredActivityNode.variable(source, target); } or 
{ StructuredClassifier.ownedAttribute(source, target); } or 
{ StructuredClassifier.ownedConnector(source, target); } or 
{ UseCase.extend(source, target); } or 
{ UseCase.extensionPoint(source, target); } or 
{ UseCase.include(source, target); }

@Surrogate(feature = "redefinedElement")
pattern redefinableElementRedefinedElement(source: RedefinableElement, target: RedefinableElement)
{ ActivityEdge.redefinedEdge(source, target); } or 
{ ActivityNode.redefinedNode(source, target); } or 
{ Classifier.redefinedClassifier(source, target); } or 
{ Connector.redefinedConnector(source, target); } or 
{ Operation.redefinedOperation(source, target); } or 
{ Property.redefinedProperty(source, target); } or 
{ RedefinableTemplateSignature.extendedSignature(source, target); } or 
{ Region.extendedRegion(source, target); } or 
{ State.redefinedState(source, target); } or 
{ Transition.redefinedTransition(source, target); }

@Surrogate(feature = "redefinitionContext")
pattern redefinableElementRedefinitionContext(source: RedefinableElement, target: Classifier)
{ find behaviorContext(source, target); } or 
{ Operation.class(source, target); } or 
{ Operation.datatype(source, target); } or 
{ Operation.interface(source, target); } or 
{ find propertyClass(source, target); } or 
{ Property.datatype(source, target); } or 
{ Property.interface(source, target); } or 
{ Property.owningAssociation(source, target); } or 
{
    // undocumented subset: Classifier.namespace
    find namedElementNamespace(source, target);
    Classifier(source);
} or {
    // undocumented subset: Classifier.namespace
    find namedElementNamespace(source, target);
    BehavioralFeature(source);
} or {
    // RedefinableTemplateSignature.classifier
    RedefinableTemplateSignature(source);
    find elementOwner(source, target);
} or {
    // Region.redefinitionContext
    find regionRedefinitionContext(source, target);
} or {
    // State.redefinitionContext
    find stateRedefinitionContext(source, target);
} or {
    // Transition.redefinitionContext
    find transitionRedefinitionContext(source, target);
}

private pattern regionRedefinitionContext (source: Region, target: Classifier){
    find regionContainingStateMachine(source, sm);
    find behaviorContext(sm, target);
} or {
    find regionContainingStateMachine(source, target);
    neg find behaviorContext(target, _);
    find classifierGeneral(target, _);
}

private pattern stateRedefinitionContext (source: State, target: Classifier){
    find vertexContainingStateMachine(source, sm);
    find behaviorContext(sm, target);
} or {
    find vertexContainingStateMachine(source, target);
    neg find behaviorContext(target, _);
    find classifierGeneral(target, _);
}

private pattern transitionRedefinitionContext (source: Transition, target: Classifier){
    find transitionContainingStateMachine(source, sm);
    find behaviorContext(sm, target);
} or {
    find transitionContainingStateMachine(source, target);
    neg find behaviorContext(target, _);
    find classifierGeneral(target, _);
}

@Surrogate(feature = "relatedElement")
pattern relationshipRelatedElement(source: Relationship, target: Element)
{ find associationEndType(source, target); } or 
{ find directedRelationshipSource(source, target); } or 
{ find directedRelationshipTarget(source, target); }

@Surrogate(feature = "role")
pattern structuredClassifierRole(source: StructuredClassifier, target: ConnectableElement)
{ Collaboration.collaborationRole(source, target); } or 
{ StructuredClassifier.ownedAttribute(source, target); }

// * Generated

/*
(let behavior: Behavior = self.containingBehavior() in
if behavior=null then null
else if behavior._'context' = null then behavior
else behavior._'context'
endif
endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: containingBehavior
@Surrogate(feature = "context")
pattern actionContext(source: Action, target: Classifier) {
    find actionContainingBehavior(source, behavior);
    find behaviorContext(behavior, target);
} or {
    find actionContainingBehavior(source, target);
    neg find behaviorContext(target, _);
}

/*
(memberEnd->collect(type)->asSet())
*/
@Surrogate(feature = "endType")
pattern associationEndType(
    self : Association,
    type : Type
) {
    Association.memberEnd(self, property);
    temp1 == property;
    TypedElement.type(temp1, type);
}

/*
 * 
 * A Behavior that is directly owned as a nestedClassifier does not have a context.
 * Otherwise, to determine the context of a Behavior, find the first
 * BehavioredClassifier reached by following the chain of owner relationships 
 * from the Behavior, if any. If there is such a BehavioredClassifier, then it
 * is the context, unless it is itself a Behavior with a non-empty context, in 
 * which case that is also the context for the original Behavior.
 * 
(if nestingClass <> null then
    null
else
    let b:BehavioredClassifier = self.behavioredClassifier(self.owner) in
    if b.oclIsKindOf(Behavior) and b.oclAsType(Behavior)._'context' <> null then 
        b.oclAsType(Behavior)._'context'
    else 
        b 
    endif
endif
        )
*/
// Can't compile OCL to VIATRA Query because of org.eclipse.ocl.SemanticException: Unrecognized variable: (nestingClass)
@Surrogate(feature = "context")
pattern behaviorContext(source: Behavior, target: BehavioredClassifier) {
    find internalBehaviorContext+(source, target);
    neg find internalBehaviorContext(target, _);
}

/*
 * Otherwise, to determine the context of a Behavior, find the first
 * BehavioredClassifier reached by following the chain of owner relationships 
 * from the Behavior, if any.
 */
private pattern internalBehaviorContext(source: Behavior, target: BehavioredClassifier) {
    neg find nestedClassifier(_, source);
    find elementOwner+(source, target);
    neg find intermediateBehaviorClassifier(source, _, target);
}

/*
 * There is an intermediate BehavioredClassifier in the ownership hierarchy
 */
private pattern intermediateBehaviorClassifier(source : Behavior, intermediate : BehavioredClassifier, target : BehavioredClassifier) {
    find elementOwner+(source, intermediate);
    find elementOwner+(intermediate, target);
}

/*
 * A Behavior that is directly owned as a nestedClassifier does not have a context.
 */
private pattern nestedClassifier(parent : Classifier, child : Classifier) {
    Class.nestedClassifier(parent, child);
} or {
    Interface.nestedClassifier(parent, child);
}

/*
(inherit(parents()->collect(inheritableMembers(self))->asSet()))
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: parents
//@Surrogate(feature = "inheritedMember")
//@QueryExplorer(checked = false)
//pattern classifierInheritedMember(source: Classifier, target: NamedElement) {}

/*
(let    ris : Set(Interface) = allRealizedInterfaces(),
        realizingClassifiers : Set(Classifier) =  self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),
        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allRealizedInterfaces())),
        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),
        providedByPorts : Set(Interface) = ports.provided->asSet()
in     ris->union(realizingClassifierInterfaces) ->union(providedByPorts)->asSet())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: allRealizedInterfaces
//@Surrogate(feature = "provided")
//pattern componentProvided(source: Component, target: Interface) {}

/*
(let    uis : Set(Interface) = allUsedInterfaces(),
        realizingClassifiers : Set(Classifier) = self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),
        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),
        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allUsedInterfaces())),
        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),
        usedByPorts : Set(Interface) = ports.required->asSet()
in      uis->union(realizingClassifierInterfaces)->union(usedByPorts)->asSet()
)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: allUsedInterfaces
//@Surrogate(feature = "required")
//pattern componentRequired(source: Component, target: Interface) {}

/*
(ConnectorEnd.allInstances()->select(role = self))
*/
@Surrogate(feature = "end")
pattern connectableElementEnd(
    self : ConnectableElement,
    temp1 : ConnectorEnd
) {
    ConnectorEnd.role(temp1, connectableElement);
    connectableElement == self;
    ConnectorEnd(connectorEnd);
    temp1 == connectorEnd;
}

/*
(if connector.type = null 
then
  null 
else
  let index : Integer = connector.end->indexOf(self) in
    connector.type.memberEnd->at(index)
endif)
*/
// Can't compile OCL to VIATRA Query because of org.eclipse.ocl.SemanticException: Unrecognized variable: (connector)
//@Surrogate(feature = "definingEnd")
//@QueryExplorer(checked = false)
//pattern connectorEndDefiningEnd(source: ConnectorEnd, target: Property) {}

/*
(deployment.deployedArtifact->select(oclIsKindOf(Artifact))->collect(oclAsType(Artifact).manifestation)->collect(utilizedElement)->asSet())
*/
@Surrogate(feature = "deployedElement")
pattern deploymentTargetDeployedElement(
    self : DeploymentTarget,
    packageableElement : PackageableElement
) {
    Artifact(artifact);
    temp2 == artifact;
    DeploymentTarget.deployment(self, deployment);
    temp1 == deployment;
    Deployment.deployedArtifact(temp1, deployedArtifact);
    temp2 == deployedArtifact;
    temp3 == temp2;
    Artifact.manifestation(temp3, manifestation);
    temp4 == manifestation;
    Manifestation.utilizedElement(temp4, packageableElement);
}

/*
(ownedAttribute->select(oclIsKindOf(Port))->collect(oclAsType(Port))->asOrderedSet())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: asOrderedSet
//@Surrogate(feature = "ownedPort")
//@QueryExplorer(checked = false)
//pattern encapsulatedClassifierOwnedPort(source: EncapsulatedClassifier, target: Port) {}

/*
(ownedEnd.lowerBound() = 1)
*/
// Can't compile OCL to VIATRA Query because of org.eclipse.ocl.SemanticException: Cannot find operation (=(Integer)) for the type (Sequence(Integer))
//@Surrogate(feature = "isRequired")
//pattern extensionIsRequired(source: Extension, target: Boolean) {}

/*
(metaclassEnd().type.oclAsType(Class))
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: metaclassEnd
//@Surrogate(feature = "metaclass")
//pattern extensionMetaclass(source: Extension, target: Class) {}

/*
(lowerBound())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: lowerBound
//@Surrogate(feature = "lower")
//pattern multiplicityElementLower(source: MultiplicityElement, target: Integer) {}

/*
(upperBound())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: upperBound
//@Surrogate(feature = "upper")
//pattern multiplicityElementUpper(source: MultiplicityElement, target: UnlimitedNatural) {}

/*
(Dependency.allInstances()->select(d | d.client->includes(self)))
*/
@Surrogate(feature = "clientDependency")
pattern namedElementClientDependency(
    self : NamedElement,
    d : Dependency
) {
    Dependency.client(d, namedElement);
    namedElement == self;
    Dependency(dependency);
    d == dependency;
}

/*
(if behavior = null then
    null
else
    behavior.ownedParameter->first()
endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.IllegalArgumentException: Unhandled parameter types: [null]
//@Surrogate(feature = "result")
//pattern opaqueExpressionResult(source: OpaqueExpression, target: Parameter) {}

/*
(if returnResult()->notEmpty() then returnResult()-> exists(isOrdered) else false endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: returnResult
//@Surrogate(feature = "isOrdered")
//pattern operationIsOrdered(source: Operation, target: Boolean) {}

/*
(if returnResult()->notEmpty() then returnResult()->exists(isUnique) else true endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: returnResult
//@Surrogate(feature = "isUnique")
//pattern operationIsUnique(source: Operation, target: Boolean) {}

/*
(if returnResult()->notEmpty() then returnResult()->any(true).lower else null endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: returnResult
//@Surrogate(feature = "lower")
//pattern operationLower(source: Operation, target: Integer) {}

/*
(if returnResult()->notEmpty() then returnResult()->any(true).type else null endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: returnResult
//@Surrogate(feature = "type")
//pattern operationType(source: Operation, target: Type) {}

/*
(if returnResult()->notEmpty() then returnResult()->any(true).upper else null endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: returnResult
//@Surrogate(feature = "upper")
//pattern operationUpper(source: Operation, target: UnlimitedNatural) {}

/*
(if self.type = String then defaultValue.stringValue() else null endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: stringValue
//@Surrogate(feature = "default")
//pattern parameterDefault(source: Parameter, target: String) {}

/*
(if isConjugated then basicRequired() else basicProvided() endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: basicRequired
//@Surrogate(feature = "provided")
//pattern portProvided(source: Port, target: Interface) {}

/*
(if isConjugated then basicProvided() else basicRequired() endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: basicProvided
//@Surrogate(feature = "required")
//pattern portRequired(source: Port, target: Interface) {}

/*
(if association <> null and association.memberEnd->size() = 2
then
    association.memberEnd->any(e | e <> self)
else
    null
endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.IllegalArgumentException: Iterator expression kind must be collect, select or reject instead of any in self.association.memberEnd->any(e : Property | e.<>(self))
//@Surrogate(feature = "opposite")
//pattern propertyOpposite(source: Property, target: Property) {}

/*
(trigger->collect(event)->select(oclIsKindOf(CallEvent))->collect(oclAsType(CallEvent).operation)->asSet())
*/
@Surrogate(feature = "referred")
pattern protocolTransitionReferred(
    self : ProtocolTransition,
    operation : Operation
) {
    CallEvent(callEvent);
    temp2 == callEvent;
    Transition.trigger(self, trigger);
    temp1 == trigger;
    Trigger.event(temp1, event);
    temp2 == event;
    temp3 == temp2;
    CallEvent.operation(temp3, operation);
}

/*
(if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter->asSet() endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.NullPointerException
//@Surrogate(feature = "inheritedParameter")
//pattern redefinableTemplateSignatureInheritedParameter(source: RedefinableTemplateSignature, target: TemplateParameter) {}

/*
(region->size () > 1)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: size
//@Surrogate(feature = "isOrthogonal")
//pattern stateIsOrthogonal(source: State, target: Boolean) {}

/*
((region->isEmpty()) and not isSubmachineState())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: isSubmachineState
//@Surrogate(feature = "isSimple")
//pattern stateIsSimple(source: State, target: Boolean) {}

/*
(submachine <> null)
*/
// Can't compile OCL to VIATRA Query because of java.lang.IllegalArgumentException: Unhandled parameter types: [null]
//@Surrogate(feature = "isSubmachineState")
//pattern stateIsSubmachineState(source: State, target: Boolean) {}

/*
(self.containingProfile())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: containingProfile
//@Surrogate(feature = "profile")
//pattern stereotypeProfile(source: Stereotype, target: Profile) {}

/*
(Transition.allInstances()->select(target=self))
*/
@Surrogate(feature = "incoming")
pattern vertexIncoming(
    self : Vertex,
    temp1 : Transition
) {
    Transition.target(temp1, vertex);
    vertex == self;
    Transition(transition);
    temp1 == transition;
}

/*
(Transition.allInstances()->select(source=self))
*/
@Surrogate(feature = "outgoing")
pattern vertexOutgoing(
    self : Vertex,
    temp1 : Transition
) {
    Transition.source(temp1, vertex);
    vertex == self;
    Transition(transition);
    temp1 == transition;
}

// * Fixed

/*
(if end->exists(
        role.oclIsKindOf(Port) 
        and partWithPort->isEmpty()
        and not role.oclAsType(Port).isBehavior)
then ConnectorKind::delegation 
else ConnectorKind::assembly 
endif)
*/
@Surrogate(feature = "kind")
pattern connectorKind(
    self : Connector,
    kind : ConnectorKind
) {
    find connectorKindDelegation(self);
    kind == ConnectorKind::delegation;
} or {
    neg find connectorKindDelegation(self);
    kind == ConnectorKind::assembly;
}

private pattern connectorKindDelegation(self: Connector) {
    Connector.end(self, end);
    ConnectorEnd.role(end, role);
    Port(role);
    neg find connectorEndPartWithPort(end, _);
    Port.isBehavior(role, false);
}

private pattern connectorEndPartWithPort(connectorEnd: ConnectorEnd, partWithPort: Property) {
    ConnectorEnd.partWithPort(connectorEnd, partWithPort);
}

/*
MessageOperations.getMessageKind
*/
@Surrogate(feature = "messageKind")
pattern messageMessageKind(self: Message, messageKind: MessageKind) {
    neg find messageSendEvent(self, _);
    neg find messageReceiveEvent(self, _);
    messageKind == MessageKind::unknown;
} or {
    neg find messageSendEvent(self, _);
    find messageReceiveEvent(self, _);
    messageKind == MessageKind::found;
} or {
    find messageSendEvent(self, _);
    neg find messageReceiveEvent(self, _);
    messageKind == MessageKind::lost;
} or {
    find messageSendEvent(self, _);
    find messageReceiveEvent(self, _);
    messageKind == MessageKind::complete;
}

private pattern messageSendEvent(self: Message, sendEvent: MessageEnd) {
    Message.sendEvent(self, sendEvent);
}

private pattern messageReceiveEvent(self: Message, receiveEvent: MessageEnd) {
    Message.receiveEvent(self, receiveEvent);
}

/*
(packagedElement->select(oclIsKindOf(Package))->collect(oclAsType(Package))->asSet())
*/
@Surrogate(feature = "nestedPackage")
pattern packageNestedPackage(
    self : Package,
    temp2 : Package
) {
    Package(package_0);
    temp1 == package_0;
    Package.packagedElement(self, packageableElement);
    temp1 == packageableElement;
    temp2 == temp1;
}

/*
(packagedElement->select(oclIsKindOf(Stereotype))->collect(oclAsType(Stereotype))->asSet())
*/
@Surrogate(feature = "ownedStereotype")
pattern packageOwnedStereotype(
    self : Package,
    temp2 : Stereotype
) {
    Stereotype(stereotype);
    temp1 == stereotype;
    Package.packagedElement(self, packageableElement);
    temp1 == packageableElement;
    temp2 == temp1;
}

/*
(packagedElement->select(oclIsKindOf(Type))->collect(oclAsType(Type))->asSet())
*/
@Surrogate(feature = "ownedType")
pattern packageOwnedType(
    self : Package,
    temp2 : Type
) {
    Type(type);
    temp1 == type;
    Package.packagedElement(self, packageableElement);
    temp1 == packageableElement;
    temp2 == temp1;
}

/*
(aggregation = AggregationKind::composite)
*/
@Surrogate(feature = "isComposite")
pattern propertyIsComposite(
    property : Property, isComposite : java Boolean
) {
    Property.aggregation(property, AggregationKind::composite);
    isComposite == true;
} or {
    Property.aggregation(property, aggregation);
    aggregation != AggregationKind::composite;
    isComposite == false;
}

/*
(region->notEmpty())
*/
@Surrogate(feature = "isComposite")
pattern stateIsComposite(
    self : State, isComposite : java Boolean
) {
    find stateIsComposite_0(self, _region);
    isComposite == true;
} or {
    neg find stateIsComposite_0(self, _region);
    isComposite == false;
}

private pattern stateIsComposite_0(
    self : State,
    region : Region
) {
    State.region(self, region);
}

/*
NamedElementOperations.getNamespace
*/
@Surrogate(feature = "namespace")
pattern namedElementNamespace(source: NamedElement, target: Namespace) {
    // opposite of Namespace.ownedMember
    find namespaceOwnedMember(target, source);
}

// * Handwritten

/*
Specifies the owning Package of this Type, if any.
*/
@Surrogate(feature = "package")
pattern typePackage(source: Type, target: Package) { 
    Package.packagedElement(target,source);
}

/*
(Extension.allInstances()->select(ext | 
  let endTypes : Sequence(Classifier) = ext.memberEnd->collect(type.oclAsType(Classifier)) in
  endTypes->includes(self) or endTypes.allParents()->includes(self) ))
*/
@Surrogate(feature = "extension")
pattern classExtension(source: Class, target: Extension) {
    Extension.memberEnd(target, memberEnd);
    Property.type(memberEnd, endType);
    Classifier(endType);
    find typeOrAllParents(endType, source);
    // XXX Class.isMetaclass is called in implementation!
}

private pattern typeOrAllParents(endType: Classifier, source: Class) {
    endType == source;
} or {
    find classifierAllParents(source, endType);
}

/*
(self.general()->select(oclIsKindOf(Class))->collect(oclAsType(Class))->asSet())
*/
@Surrogate(feature = "superClass")
pattern classSuperClass(source: Class, target: Class) {
    find classifierGeneral(source, target);
}

/*
(parents()->union(parents()->collect(allParents())->asSet()))
*/
private pattern classifierAllParents(source: Classifier, target: Classifier) {
    find classifierParents+(source, target);
}

/*
(parents())
*/
@Surrogate(feature = "general")
pattern classifierGeneral(source: Classifier, target: Classifier) {
    neg find isClass(source);
    find classifierParents(source, target);
} or {
    // Class.superClass redefines general
    find isClass(source);
    find classifierParents(source, target);
    find isClass(target);
}

private pattern isClass(cls : Class) {
    Class(cls);
}


// connectorEndDefiningEnd: ordered

/*
(ownedAttribute->select(oclIsKindOf(Port))->collect(oclAsType(Port))->asOrderedSet())
*/
// WARNING: ordering is not preserved
@Surrogate(feature = "ownedPort")
pattern encapsulatedClassifierOwnedPort(source: EncapsulatedClassifier, target: Port) {
    EncapsulatedClassifier.ownedAttribute(source, target);
}

/*
(metaclassEnd().type.oclAsType(Class))
*/
@Surrogate(feature = "metaclass")
pattern extensionMetaclass(source: Extension, target: Class) {
    find extensionMetaclassEnd(source, metaclassEnd);
    Property.type(metaclassEnd, target);
}

/*
(memberEnd->reject(p | ownedEnd->includes(p.oclAsType(ExtensionEnd)))->any(true))
*/
private pattern extensionMetaclassEnd(source: Extension, target: Property) {
    Extension.memberEnd(source, target);
    neg find extensionOwnedEnd(source, target);
}

private pattern extensionOwnedEnd(source: Extension, target: ExtensionEnd) {
    Extension.ownedEnd(source, target);
}

/*
(if self.name <> null and self.allNamespaces()->select( ns | ns.name=null )->isEmpty()
then 
    self.allNamespaces()->iterate( ns : Namespace; agg: String = self.name | ns.name.concat(self.separator()).concat(agg))
else
   null
endif)
*/
@Surrogate(feature = "qualifiedName")
pattern namedElementQualifiedName(namedElement: NamedElement, qualifiedName : java String) {
    neg find internalNamedElementNamespace(namedElement, _);
    NamedElement.name(namedElement, qualifiedName);
    // qualifiedName is null if any of the names are empty!
    qualifiedName != "";
} or {
    find internalNamedElementNamespace(namedElement, namespace);
    NamedElement.name(namedElement, name);
    // qualifiedName is null if any of the names are empty!
    name != "";
    find namedElementQualifiedName(namespace, namespaceQualifiedName);
    qualifiedName == eval(namespaceQualifiedName + "::" + name); // XXX is separator always this?
}

// NamedElement owned by TemplateParameter is handled separately when computing namespace
private pattern internalNamedElementNamespace(namedElement: NamedElement, namespace : Namespace) {
    find namedElementNamespace(namedElement, namespace);
} or {
    find elementOwner(namedElement, parameter);
    TemplateableElement.ownedTemplateSignature.ownedParameter(namespace, parameter);
}

/*
(self.importMembers(elementImport.importedElement->asSet()->union(packageImport.importedPackage->collect(p | p.visibleMembers()))->asSet()))
*/
@Surrogate(feature = "importedMember")
pattern namespaceImportedMember(namespace: Namespace, importedMember: PackageableElement) {
    Namespace.elementImport(namespace, elementImport);
    ElementImport.importedElement(elementImport, importedMember);
} or {
    Namespace.packageImport(namespace, packageImport);
    PackageImport.importedPackage(packageImport, importedPackage);
    find packageVisibleMember(importedPackage, importedMember);
}

/*
(if behavior = null then
    null
else
    behavior.ownedParameter->first()
endif)
*/
@Surrogate(feature = "result")
pattern opaqueExpressionResult(source: OpaqueExpression, target: Parameter) {
    OpaqueExpression.behavior.ownedParameter(source, target); // XXX only first?
}

/*
(member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))->collect(oclAsType(PackageableElement))->asSet())
*/
private pattern packageVisibleMember(package_: Package, visibleMember: PackageableElement) {
    find packageDirectlyVisibleMember(package_, visibleMember);
} or {
    find packageAllImportedPackages(package_, importedPackage);
    find packageDirectlyVisibleMember(importedPackage, visibleMember);
}

private pattern packageDirectlyVisibleMember(package_: Package, directlyVisibleMember: PackageableElement) {
    find namespaceOwnedMember(package_, directlyVisibleMember);
    NamedElement.visibility(directlyVisibleMember, ::public);
} or {
    Package.elementImport(package_, elementImport);
    ElementImport.visibility(elementImport, ::public);
    ElementImport.importedElement(elementImport, directlyVisibleMember);
}

private pattern packageAllImportedPackages(package_: Package, importedPackage: Package) {
    find packageImportedPackage+(package_, importedPackage);
}

private pattern packageImportedPackage(package_: Package, importedPackage: Package) {
    Namespace.packageImport(package_, packageImport);
    PackageImport.visibility(packageImport, ::public);
    PackageImport.importedPackage(packageImport, importedPackage);
}

@Surrogate(feature = "nestingPackage")
pattern packageNestingPackage(nested: Package, nesting: Package) {
    find packageNestedPackage(nesting, nested);
}

/*
(if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter->asSet() endif)
*/
@Surrogate(feature = "inheritedParameter")
pattern redefinableTemplateSignatureInheritedParameter(source: RedefinableTemplateSignature, target: TemplateParameter) {
    RedefinableTemplateSignature.extendedSignature.parameter(source, target);
}

/*
(ownedAttribute->select(isComposite)->asSet())
*/
@Surrogate(feature = "part")
pattern structuredClassifierPart(structuredClassifier: StructuredClassifier, part: Property) {
    StructuredClassifier.ownedAttribute(structuredClassifier, part);
    find propertyIsComposite(part, true);
}

/*
(region->size () > 1)
*/
@Surrogate(feature = "isOrthogonal")
pattern stateIsOrthogonal(source: State, target : java Boolean) {
    regionCount == count find stateIsComposite_0(source, _region);
    target == eval(regionCount > 1);
}

// * Used operations

/*
(if inStructuredNode<>null then inStructuredNode.containingBehavior() 
else if activity<>null then activity
else interaction 
endif
endif
)
*/
// Can't compile OCL to VIATRA Query because of org.eclipse.ocl.SemanticException: Unrecognized variable: (interaction)
private pattern actionContainingBehavior(source: Action, target: Behavior) {
    find activityNodeActivity(source, target);
} or {
    Action.inStructuredNode(source, node);
    find actionContainingBehavior(node, target);
} or {
    Interaction.action(target, source);
}

/*
(directlyRealizedInterfaces()->union(self.allParents()->collect(directlyRealizedInterfaces()))->asSet())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: directlyRealizedInterfaces
//pattern classifierAllRealizedInterfaces(source: Classifier, target: Interface) {}

/*
(directlyUsedInterfaces()->union(self.allParents()->collect(directlyUsedInterfaces()))->asSet())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: directlyUsedInterfaces
//pattern classifierAllUsedInterfaces(source: Classifier, target: Interface) {}

/*
(inhs->reject(inh |
  inh.oclIsKindOf(RedefinableElement) and
  ownedMember->select(oclIsKindOf(RedefinableElement))->
    select(redefinedElement->includes(inh.oclAsType(RedefinableElement)))
       ->notEmpty()))
*/
// Can't compile OCL to VIATRA Query because of org.eclipse.ocl.SemanticException: Unrecognized variable: (inhs)
//pattern classifierInherit(source: Classifier, target: NamedElement) {}

/*
(member->select(m | c.hasVisibilityOf(m)))
*/
// Can't compile OCL to VIATRA Query because of org.eclipse.ocl.SemanticException: Unrecognized variable: (c)
//pattern classifierInheritableMembers(source: Classifier, target: NamedElement) {}

/*
(generalization.general->asSet())
*/
private pattern classifierParents(
    self : Classifier,
    classifier : Classifier
) {
    Classifier.generalization(self, generalization);
    temp1 == generalization;
    Generalization.general(temp1, classifier);
}

/*
(memberEnd->reject(p | ownedEnd->includes(p.oclAsType(ExtensionEnd)))->any(true))
*/
// Can't compile OCL to VIATRA Query because of java.lang.IllegalArgumentException: Iterator expression kind must be collect, select or reject instead of any in self.memberEnd->reject(p : Property | self.ownedEnd->includes(p.oclAsType(uml::ExtensionEnd)))->any(temp1 : Property | true)
//pattern extensionMetaclassEnd(source: Extension, target: Property) {}

/*
(if (lowerValue=null or lowerValue.integerValue()=null) then 1 else lowerValue.integerValue() endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: integerValue
//pattern multiplicityElementLowerBound(source: MultiplicityElement, target: Integer) {}

/*
(if (upperValue=null or upperValue.unlimitedValue()=null) then 1 else upperValue.unlimitedValue() endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: unlimitedValue
//pattern multiplicityElementUpperBound(source: MultiplicityElement, target: UnlimitedNatural) {}

/*
(ownedParameter->select (direction = ParameterDirectionKind::return)->asSet())
*/
//private pattern operationReturnResult(
//    self : Operation,
//    temp1 : Parameter
//) {
//    Parameter.direction(temp1, parameterDirectionKind);
//    parameterDirectionKind_0 == ParameterDirectionKind::^return;
//    parameterDirectionKind == parameterDirectionKind_0;
//    BehavioralFeature.ownedParameter(self, parameter);
//    temp1 == parameter;
//}

/*
(member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))->collect(oclAsType(PackageableElement))->asSet())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: makesVisible
//pattern packageVisibleMembers(source: Package, target: PackageableElement) {}

/*
(if type.oclIsKindOf(Interface) 
then type.oclAsType(Interface)->asSet() 
else type.oclAsType(Classifier).allRealizedInterfaces() 
endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: allRealizedInterfaces
//pattern portBasicProvided(source: Port, target: Interface) {}

/*
( type.oclAsType(Classifier).allUsedInterfaces() )
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: allUsedInterfaces
//pattern portBasicRequired(source: Port, target: Interface) {}

/*
(if stateMachine = null 
then
  state.containingStateMachine()
else
  stateMachine
endif)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: containingStateMachine
private pattern regionContainingStateMachine(source: Region, target: StateMachine) {
    find stateMachineContainment+(source, target);
}

/*
(submachine <> null)
*/
// Can't compile OCL to VIATRA Query because of java.lang.IllegalArgumentException: Unhandled parameter types: [null]
//pattern stateIsSubmachineState(source: State, target: Boolean) {}

/*
(self.namespace.oclAsType(Package).containingProfile())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: containingProfile
//pattern stereotypeContainingProfile(source: Stereotype, target: Profile) {}

/*
(container.containingStateMachine())
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: containingStateMachine
private pattern transitionContainingStateMachine(source: Transition, target: StateMachine) {
    find stateMachineContainment+(source, target);
}

/*
(null)
*/
// Can't compile OCL to VIATRA Query because of java.lang.IllegalArgumentException: Unhandled parameter types: [null]
//pattern valueSpecificationStringValue(source: ValueSpecification, target: String) {}

/*
(if container <> null
then
-- the container is a region
   container.containingStateMachine()
else 
   if (self.oclIsKindOf(Pseudostate)) and ((self.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint) or (self.oclAsType(Pseudostate).kind = PseudostateKind::exitPoint)) then
      self.oclAsType(Pseudostate).stateMachine
   else 
      if (self.oclIsKindOf(ConnectionPointReference)) then
          self.oclAsType(ConnectionPointReference).state.containingStateMachine() -- no other valid cases possible
      else 
          null
      endif
   endif
endif
)
*/
// Can't compile OCL to VIATRA Query because of java.lang.UnsupportedOperationException: containingStateMachine
private pattern vertexContainingStateMachine(source: Vertex, target: StateMachine) {
    find stateMachineContainment+(source, target);
}

private pattern stateMachineContainment(child : NamedElement, container : NamedElement)
{ Vertex.container(child, container); } or 
{ Pseudostate.stateMachine(child, container); } or
{ ConnectionPointReference.state(child, container); } or
{ Transition.container(child, container); } or
{ Region.state(child, container); } or 
{ Region.stateMachine(child, container); }